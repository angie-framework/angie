<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../">
  <title data-ice="title">src/services/BaseRequest.js | API Document</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
</head>
<body class="layout-container">

<header>
  <a href="./">Home</a>
  <a href="identifiers.html">Identifier</a>
  <a href="source.html">Source</a>
  
  <a data-ice="repoURL" href="https://github.com/benderTheCrime/angie.git" class="repo-url-github">Repository</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div data-ice="classWrap">
  <h2>Class</h2>
  <ul>
    
  <li data-ice="classDoc"><span><a href="class/src/util/$ExceptionsProvider.js~$$InvalidConfigError.html">$$InvalidConfigError</a></span></li>
<li data-ice="classDoc"><span><a href="class/src/factories/$CacheFactory.js~$CacheFactory.html">$CacheFactory</a></span></li>
<li data-ice="classDoc"><span><a href="class/src/util/$MimeTypeProvider.js~$MimeTypeProvider.html">$MimeTypeProvider</a></span></li>
<li data-ice="classDoc"><span><a href="class/src/services/$Request.js~$Request.html">$Request</a></span></li>
<li data-ice="classDoc"><span><a href="class/src/services/$Responses.js~$Response.html">$Response</a></span></li>
<li data-ice="classDoc"><span><a href="class/src/factories/$RouteProvider.js~$RouteProvider.html">$RouteProvider</a></span></li>
<li data-ice="classDoc"><span><a href="class/src/factories/$TemplateCache.js~$TemplateCache.html">$TemplateCache</a></span></li>
<li data-ice="classDoc"><span><a href="class/src/factories/$Compile.js~$window.html">$window</a></span></li>
<li data-ice="classDoc"><span><a href="class/src/Angie.js~Angie.html">Angie</a></span></li>
<li data-ice="classDoc"><span><a href="class/src/services/BaseRequest.js~BaseRequest.html">BaseRequest</a></span></li>
<li data-ice="classDoc"><span><a href="class/src/Config.js~Config.html">Config</a></span></li>
</ul>
</div>



<div data-ice="functionWrap">
  <h2><a href="function/">Function</a></h2>
  <ul>
    
  <li data-ice="functionDoc"><span><a href="function/index.html#static-function-Base">Base</a></span></li>
<li data-ice="functionDoc"><span><a href="function/index.html#static-function-shell">shell</a></span></li>
<li data-ice="functionDoc"><span><a href="function/index.html#static-function-watch">watch</a></span></li>
</ul>
</div>






</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/services/BaseRequest.js</h1>
<pre class="source-code line-number"><code class="prettyprint linenums" data-ice="content">/**
 * @module BaseRequest.js
 * @author Joe Groseclose &lt;@benderTheCrime&gt;
 * @date 8/16/2015
 */

// System Modules
import $LogProvider from                        &apos;angie-log&apos;;
import {$injectionBinder} from                  &apos;angie-injector&apos;;

// Angie Modules
import app from                                 &apos;../Angie&apos;;
import {config} from                            &apos;../Config&apos;;
import $Request from                            &apos;./$Request&apos;;
import {$Response} from                         &apos;./$Responses&apos;;
import {default as $Routes} from                &apos;../factories/$RouteProvider&apos;;
import {
    $templateCache,
    $$templateLoader,
    $resourceLoader
} from                                          &apos;../factories/$TemplateCache&apos;;
import $compile from                            &apos;../factories/$Compile&apos;;
import {default as $MimeType} from              &apos;../util/$MimeTypeProvider&apos;;

import $Util, {
    $StringUtil
} from                                          &apos;../util/Util&apos;;

app.constant(&apos;RESPONSE_HEADER_MESSAGES&apos;, {
    200: &apos;OK&apos;,
    404: &apos;File Not Found&apos;,
    500: &apos;Invalid Request&apos;
}).constant(
    &apos;PRAGMA_HEADER&apos;,
    &apos;no-cache&apos;
).constant(
    &apos;NO_CACHE_HEADER&apos;,
    &apos;private, no-cache, no-store, must-revalidate&apos;
);

/**
 * @desc The BaseRequest class processes all of the incoming Angie requests. It
 * can be required using a module import, but probably should not be unless it
 * it being subclassed for a dependency package.
 * @todo Make this class private ($$)
 * @todo Move base request
 * @since 0.0.1
 */
class BaseRequest {
    constructor(path, request, response) {

        // Shortcut to set and receive the request object
        this.request = new $Request(request).request;

        // Define URI
        this.path = this.request.path = path;

        // Make the response object available to the API
        this.response = new $Response(response).response;
        this.response.$responseContent = &apos;&apos;;

        // Parse out the response content type
        let contentType = this.request.headers.accept;

        if (contentType &amp;&amp; contentType.indexOf(&apos;,&apos;) &gt; -1) {
            contentType = contentType.split(&apos;,&apos;)[0];
        } else {
            contentType = $MimeType.fromPath(path);
        }

        this.responseContentType = contentType;
        this.responseHeaders = {
            &apos;Content-Type&apos;: this.responseContentType
        };

        // Grab the routes and the otherwise
        this.routes = $Routes.fetch().routes;
        this.otherwise = $Routes.fetch().otherwise;
    }

    /**
     * @desc This method performs the route on the incoming request object and
     * the associated path. If there is a matching path using RegExp, the
     * existing matched params will be parsed out of the path. If not, a standard
     * router will be used.
     * @since 0.2.3
     * @returns {function} BaseRequest.prototype.$controllerPath or
     * BaseRequest.prototype.otherPath
     */
    $$route() {

        // Check against all of the RegExp routes in Reverse
        let regExpRoutes = [];
        if (this.routes.regExp) {
            regExpRoutes = Object.keys(this.routes.regExp).reverse();
        }

        for (let i = 0; i &lt; regExpRoutes.length; ++i) {

            // Slice characters we do not need to instantiate a new RegExp
            let regExpRoute =
                $StringUtil.removeTrailingLeadingSlashes(regExpRoutes[ i ]),

                // Cast the string key of the routes.regExp object as a
                // RegExp obj
                pattern = new RegExp(regExpRoute);

            if (pattern.test(this.path)) {
                this.route = this.routes.regExp[ regExpRoutes[ i ] ];

                // Hooray, we&apos;ve set our route, now we need to do some additional
                // param parsing
                $Util._extend(
                    this.request.query,
                    $Routes.$$parseURLParams(pattern, this.path)
                );

                break;
            }
        }

        // Check for a matching string path
        if (!this.route &amp;&amp; this.routes[ this.path ]) {
            this.route = this.routes[ this.path ];
        }

        // Route the request based on whether the route exists
        if (this.route) {
            return this.$controllerPath();
        }
        return this.otherPath();
    }

    /**
     * @desc $controllerPath is fired once a request has been routed. It fires
     * the controller once dependencies have been injected.
     *
     * Cases:
     *     Controller &amp; templatePath (default): Compiles template in scope
     *     Controler &amp; template: Compiles template in scope
     *     Controller: fires Controller, expects response
     *     TemplatePath (default): Serves template, expects compilation on
     * frontend
     *     Template: Serves template, expects compilation on frontend
     *
     * If the loadDefaultScriptFile option is added to AngieFile.json with a
     * valid (existing and of type &quot;.js&quot;) JavaScript filename, this default
     * script file will be loaded.
     * @todo add documentation on views
     * @since 0.2.3
     * @access private
     */
    $controllerPath() {
        let me = this,
            prom;

        // TODO move all of this out to responses
        prom = new Promise(function(resolve, reject) {

            // TODO despite the fact that controllerName is kind of a misnomer,
            // because this can be a function, it is ok for now
            let controllerName = me.route.Controller;

            // Get controller and compile scope
            if (controllerName) {
                if (
                    app.Controllers[ controllerName ] ||
                    typeof controllerName === &apos;function&apos;
                ) {

                    // Check to see if the Controller in the Route is a function
                    let controller = typeof me.route.Controller !== &apos;function&apos; ?
                        app.Controllers[ controllerName ] : controllerName;

                    app.Controller = app.services.$response.Controller = {
                        done: resolve
                    };

                    me.controller = new $injectionBinder(
                        controller,
                        &apos;controller&apos;
                    ).call(
                        app.services.$scope,
                        resolve
                    );
                    if (
                        !me.controller ||
                        !me.controller.constructor ||
                        me.controller.constructor.name !== &apos;Promise&apos;
                    ) {
                        resolve(controllerName);
                    }
                } else {

                    // TODO controller was not found despite being defined?
                    // TODO exception
                    reject(`No Controller named &quot;${controllerName}&quot; could be found`);
                }
            } else {
                resolve(controllerName);
            }
        });

        // Find and load template
        prom = prom.then(function(controllerName) {
            let mime;

            if (
                me.route.template &amp;&amp;
                typeof me.route.template === &apos;string&apos; &amp;&amp;
                me.route.template.length &gt; 0
            ) {
                me.template = me.route.template;
            } else if (me.route.templatePath) {
                let template = $templateCache.get(me.route.templatePath);

                // Check to see if we can associate the template path with a
                // mime type
                mime = $MimeType.fromPath(me.route.templatePath);


                // Check the caching options for static assets
                // This should only be for templatePaths with &quot;.&quot;&apos;s,
                // all others should apply to caching options
                if (
                    me.route.templatePath.indexOf(&apos;.&apos;) &gt; -1 &amp;&amp;
                    config.hasOwnProperty(&apos;cacheStaticAssets&apos;) &amp;&amp;
                    !config.cacheStaticAssets
                ) {

                    // If there is a template, check to see if caching is set
                    me.responseHeaders = $Util._extend(me.responseHeaders, {
                        Expires: -1,
                        Pragma: app.constants.PRAGMA_HEADER,
                        &apos;Cache-Control&apos;: app.constants.NO_CACHE_HEADER
                    });
                }

                me.responseHeaders[ &apos;Content-Type&apos; ] = mime;
                me.template = template;
            }

            // If there is a template/templatePath defined we should have a template
            if (!me.template) {
                if (me.route.template || me.route.templatePath) {
                    return me.unknownPath();
                }
            } else {

                // If we have any sort of template
                let match;

                // In the context where MIME type is not set, but we have a
                // DOCTYPE tag, we can force set the MIME
                // We want this here instead of the explicit template definition
                // in case the MIME failed earlier
                if (match = me.template.toString().match(/!doctype ([a-z]+)/i)) {
                    mime = me.responseHeaders[ &apos;Content-Type&apos; ] =
                        $MimeType.$$(match[1].toLowerCase());
                }

                // Check to see if this is an HTML template and has a DOCTYPE
                // and that the proper configuration options are set
                if (
                    (
                        mime || me.responseHeaders[ &apos;Content-Type&apos; ]
                    ) === &apos;text/html&apos; &amp;&amp;
                    config.loadDefaultScriptFile &amp;&amp;
                    (
                        !me.route.hasOwnProperty(&apos;useMainScriptFile&apos;) ||
                        me.route.useDefaultScriptFile !== false
                    )
                ) {

                    console.log(&apos;IM IN!!!&apos;);

                    // Check that option is not true
                    let scriptFile = config.loadDefaultScriptFile === true ?
                        &apos;application.js&apos; : config.loadDefaultScriptFile;
                    $resourceLoader(scriptFile);
                }

                // Pull the response back in from wherever it was before
                me.responseContent = me.response.$responseContent;

                // Render the template into the resoponse
                return new Promise(function(resolve) {

                    // $Compile to parse template strings and app.directives
                    return $compile(me.template)(

                        // In the context of the scope
                        app.services.$scope
                    ).then(function(template) {
                        resolve(template);
                    });
                }).then(function(template) {
                    me.responseContent += template;
                    me.response.$responseContent = me.responseContent;

                    return controllerName;
                });
            }
        });

        // TODO See if any views have this Controller associated
        // TODO if no response type associated, use extension (already set)
        // prom = prom.then(function(controllerName) {
        //     for (let key in app.$registry) {
        //         if (app.$registry[ key ] === &apos;directive&apos;) {
        //             let directive = app.directives[ key ];
        //             if (
        //                 directive.Controller &amp;&amp;
        //                 typeof directive.Controller !== &apos;function&apos;
        //                 directive.Controller === controllerName &amp;&amp;
        //                 directive.type === &apos;APIView&apos;
        //             ) {
        //
        //                 // APIViews cannot have templates, all templates are trashed
        //                 if (me.template) {
        //                     delete me.template;
        //                     delete me.$responseContent;
        //
        //                     //me.responseHeaders = {};
        //                     $log.warn(
        //                         `Attempted to load template on view ${key}: ` +
        //                         &apos;Templates cannot be rendered by an APIView&apos;
        //                     );
        //                 }
        //
        //
        //                 // We have made it so only one APIView directive can
        //                 // be fired at a time
        //                 break;
        //             }
        //         }
        //     }
        // });

        prom.then(function() {
            me.response.writeHead(
                200,
                app.constants.RESPONSE_HEADER_MESSAGES[ &apos;200&apos; ],
                me.responseHeaders
            );
            me.response.write(me.responseContent);
        });

        prom.catch(function(e) {
            $LogProvider.error(e);
            return me.errorPath();
        });

        return prom;
    }
    otherPath() {
        let me = this;

        if (this.otherwise) {

            // Redirect the page to a default page
            // TODO test otherwise redirects to absolute path or full link
            return new Promise(function() {
                me.response.statusCode = 302;
                me.response.setHeader(&apos;Location&apos;, `${me.otherwise}`);
                arguments[0]();
            });
        }

        return this[ `${ this.path === &apos;/&apos; ? &apos;default&apos; : &apos;unknown&apos; }Path` ]();
    }
    defaultPath() {

        // Load default page
        let index = $$templateLoader(&apos;index.html&apos;);

        // If the index page could not be found
        if (!index) {
            return this.unknownPath();
        }

        // Write the response
        let me = this;
        return new Promise(function() {
            me.response.writeHead(
                200,
                app.constants.RESPONSE_HEADER_MESSAGES[&apos;200&apos;],
                me.responseHeaders
            );
            me.response.write(index);
            arguments[0]();
        });
    }
    unknownPath() {

        // Load page not found
        let fourOhFour = $$templateLoader(&apos;404.html&apos;),
            me = this;

        return new Promise(function() {
            me.response.writeHead(
                404,
                app.constants.RESPONSE_HEADER_MESSAGES[&apos;404&apos;],
                me.responseHeaders
            );
            me.response.write(fourOhFour);
        });
    }
    errorPath() {
        this.response.writeHead(
            500,
            app.constants.RESPONSE_HEADER_MESSAGES[ &apos;500&apos; ],
            this.responseHeaders
        );
        this.response.write(
            `&lt;h1&gt;${app.constants.RESPONSE_HEADER_MESSAGES[ &apos;500&apos; ]}&lt;/h1&gt;`
        );
    }
}

export {BaseRequest};

// TODO break up this file
    // BaseRequest
        // ControllerRequest
            // ControllerWithTemplate
            // ControllerWithTemplatePath
            // ControllerWithView
        // UnkownRequest
        // ErrorRequest</code></pre>
</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.1.2)</span></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
